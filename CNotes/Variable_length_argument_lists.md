# Список аргументов переменное длины (Variable-length argument list)

В качестве литературы использовался следующий параграф: [Brian Kernighan, Dennis Ritchie "The_C_Programming_Language", 7.3. Variable-length Argument Lists]

## Введение

Рассмотрим в качестве примера функцию `function()`, которая имеет следующую сигнатуру:

```c
void function(char *named_arg, ...);
```

Многоточие `...` в объявлении функции означает, что число и типы аргументов могут варьироваться для каждого отдельного вызова данной функции. Сразу отметим, что знак многоточия `...` может находиться только в конце списка аргументов функции. Сложность в данном случае заключается в итерировании по данному списку аргументов, ведь у него нет даже имени, по которому можно было бы обратиться.

## Модуль stdarg.h

Модуль `stdarg.h` стандартной библиотеки C содержит набор макроопределений (macro definitions), который позволяют итерироваться по списку аргументов переменной длины. 

| Макрос       | Описание                                                                                                                                                                        |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `va_list`    | Тип данных для декларации переменной, которая по очереди ссылается на каждый аргумент из списка.                                                                                |
| `va_start()` | Инициализирует `va_list` для использования, устанавливая указатель на первый неименованный аргумент. Необходимо вызвать единожды до первого использования переменной `va_list`. |
| `va_copy()`  | Создает полную независимую копию уже инициализированного `va_list`.                                                                                                             |
| `va_arg()`   | На каждом вызове возвращает очередной аргумент и сдвигает указатель `va_list` на следующий.                                                                                     |
| `va_end()`   | Производит очистку всего необходимого. Следует вызвать перед самым выходом из функции.                                                                                          |

### va_list

`va_list` — это полноценный тип объекта, подходящий для хранения информации, необходимой макросам `va_start()`, `va_copy()`, `va_arg()` и `va_end()`. 

Если экземпляр `va_list` создан, передан другой функции и используется в текущей функции через `va_arg()`, то любому последующему использованию в вызывающей (текущей) функции должен предшествовать вызов `va_end()`. 

Допускается передача указателя на объект `va_list` другой функции и последующее использование этого объекта после завершения работы функции.

### va_start()

Макрос `va_start()` обеспечивает доступ к переменным аргументам (содержащимся в списке `...`), следующим за именованным аргументом `named_arg` (до С23).

```c
void va_start(va_list ap, named_arg); // until C23
void va_start(va_list ap, ...);       // since C23
```
* `ap`        - экземпляр типа `va_list`;
* `named_arg` - именованный параметр, предшествующий списку аргументов переменной длины.

`va_start()` должен быть вызван с экземпляром допустимого объекта `va_list ap` перед каким-либо вызовом `va_arg()`.

Если `named_arg` объявлен со спецификатором класса хранения регистров ( register storage class specifier), с типом массива, с типом функции или с типом, несовместимым с типом, полученным в результате продвижения аргументов по умолчанию (default argument promotions), поведение не определено.

Использовать список аргументов переменной длины без фиксированного параметра именованного параметра перед ними небезопасно.

### va_copy()

```c
void va_copy(va_list dest, va_list src); //since C99
```
* `dest` - экземпляр типа `va_list` для инициализации;
* `src`  - исходный `va_list`, который будет использоваться для инициализации `dest`.

Макрос `va_end()` следует вызывать для `dest` перед возвратом из функции или любой последующей повторной инициализацией `dest` (посредством вызовов `va_start()` или `va_copy()`).

Для передачи `va_list` в другую функцию в качестве копии хорошей практикой считается использование `va_copy()`. Это связано с тем, что это `va_list` - непрозрачный тип, который может быть реализован по-разному в разных компиляторах. Он может быть:
-  указателем на стек;
-  структурой с информацией о позиции;
-  массивом.
Передача в функцию в свою очередь может модифицировать его внутреннее состояние (продвинуть указатель), что приведет к неопределенному поведению.

#### Пример использования

```c
double sample_stddev(int count, ...) {
    // Compute the mean with args1
    double sum = 0;
    va_list args1;
    va_start(args1, count);
    va_list args2;
    va_copy(args2, args1);   // copy va_list object 
    for (int i = 0; i < count; ++i) {
        double num = va_arg(args1, double);
        sum += num;
    }
    va_end(args1);
    double mean = sum / count;
 
    // Compute standard deviation with args2 and mean. 
    double sum_sq_diff = 0;
    for (int i = 0; i < count; ++i) {
        double num = va_arg(args2, double);
        sum_sq_diff += (num-mean) * (num-mean);
    }
    va_end(args2);
    return (sum_sq_diff / count);
}
```
### va_arg()

Макрос `va_arg()` раскрывается в выражение типа `T`, соответствующее следующему параметру из списка `va_list ap`.

```c
T va_arg(va_list ap, T);
```
*  `ap` - экземпляр типа `va_list`; 
*  `T`  - тип следующего параметра в `ap`.

Перед вызовом `va_arg()`, `ap` должен быть инициализирован вызовом `va_start()` или `va_copy()` без промежуточного вызова `va_end()`. Каждый вызов макроса `va_arg()` изменяет `ap` так, чтобы он указывал на следующий аргумент из списка аргументов переменной длины (`...`).

Если тип следующего аргумента в `ap` (после продвижения) несовместим с `T`, поведение не определено, за исключением следующих случаев: 
 * один тип     - знаковый целый тип, другой тип - соответствующий беззнаковый целый тип, и значение может быть представлено в обоих типах;
 * или один тип - указатель на `void`, а другой — указатель на символьный тип.

Если `va_arg()` вызывается, когда в `ap` больше нет аргументов, поведение не определено.

### va_end()

Макрос `va_end()` выполняет очистку объекта `ap`, инициализированного вызовом `va_start()` или `va_copy()`. 

```c
void va_end(va_list ap);
```
* `ap` - экземпляр типа `va_list` для очистки.

`va_end()` может изменить `ap`, сделав его непригодным к использованию.

Если соответствующий вызов `va_start()` или `va_copy()` отсутствует, или если `va_end()` не вызван до возврата управления из функции, вызывающей `va_start()` или `va_copy()`, поведение не определено.

## Пример работы

```c
void function(char *named_arg, ...) {
	// Указывает на очередной безымянный аргумен из списка ...
	va_list arg_pointer; 
	
	int int_val = 0;
	double double_val = 0.0;
	
	// Устанавливает ap на первый аргумент за named_arg
	va_start(arg_pointer, named_arg); 
	for (char *pointer = named_arg; *pointer; ponter++) {
		if (*pointer != '%') {
			putchar(*pointer);
			continue;
		}
		switch (*++pointer) {
		case 'd':
			int_val = va_arg(arg_pointer, int);
			break;
		case 'f':
			double_val = va_arg(arg_pointer, double);
			break;
		case 's':
				for (char *string_val = va_arg(arg_pointer, char *); *string_val;                       string_val++) {
					putchar(*string_val);
				}
				break;
		default:
			putchar(*pointer);
			break;
		}
	}
	// Очистка памяти перед выходом из функции
	va_end(arg_pointer);
}
```