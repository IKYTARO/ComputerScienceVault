# Регулярные выражения (regular expressions)

### Введение

Регулярные выражения - это специальный инструмент для работы с текстом, который позволяет вычленять определенные шаблоны (или паттерны) и производить по ним поиск. Сам по себе синтаксис регулярных выражений достаточно запутан, например шаблон позволяющий найти строку со временем в формате ЧЧ:ММ будет выглядеть так:
```
\b([01]?[0-9]|2[0-3]):([0-5]\d)\b
```
Для тренировки и изучения базовых аспектов синтаксиса регулярных выражений можно использовать следующие ресурсы:
-  [Уроки](https://regexone.com/)
-  [Упражнения](http://regextutorials.com/)

### Модуль regex.h

В стандартной библиотеке языка С существует модуль `regex.h`, который предоставляет базовый функционал для поиска, сопоставления и обработки строк. 

#### 1. Создание регулярных выражений

Для обработки регулярного выражения и придания ему формы, которая пригодна для последующих **regexec**-поисков используется функция **regcomp()**:

```c
int regcomp(regex_t *regex, const char *expression, int flag);
```
-  `regex`          : указатель на область хранения буферного шаблона специального типа                                  `regex_t`;
-  `expression` : строка - регулярное выражение;
-  `flag`            : флаг для определения типа обработки;
-  `return`        : в случае успеха возвращает 0, и **errcode** - в случае неудачи.

Каждый поиск регулярного выражения должен осуществляться с помощью обработанного буферного шаблона  таким образом, чтобы **regexec()** всегда поддерживалась адресом инициализированного функцией **regcomp()** буферного шаблона.   

Для переменной **flag** в рассматриваемом модуле заведено несколько типовых значений, которые можно использовать, например:
-  `REG_BASIC` : базовый функционал регулярных выражений(+ и ? считаются обычными                               символами);
-  `REG_ICASE` : не учитывать регистр. Последующие поиски **regexec** с использованием                                  данного буферного шаблона не будут зависеть от регистра;
-  `REG_GREP`   : указывает на поведение, похожее на `grep`;
-  `...`

#### 2. Поиск по регулярному выражению

Для сравнения строки, завершающейся нулем, с предварительно обработанным буферным шаблоном **regex** (с помощью функции **regcomp()**) используется функция **regexec()**:

```c
int regexec(const regex_t *regex, const char *string, size_t nmatch,
            regmatch_t pmatch[], int* flags);
```
-  `regex`    :  шаблон для поиска;
-  `string` :  строка, в которой происходит поиск;
-  `nmatch` :  количество элементов в массиве pmatch (сколько подстрок надо найти)  или 0 - если не нужна инфа о подстроках.
-  `pmatch` :  массив структур типа `regmatch_t`, в котором каждый элемент - совпадение:                         `pmatch.rm_so` - начало совпадения (индекс); `pmatch.rm_eo` - конец совпадения                      (индекс), `NULL` - если не нужен.
-  `flags`    :  флаги, которые определяют поведение процесса сравнения (обычно 0);
-  `return` :  возвращает ноль при совпадениях или `REG_NOMATCH`, если совпадений не                              было.

Подробнее о флагах можно поискать в [документации](https://www.opennet.ru/man.shtml?topic=regex&category=3&russian=0) или погуглить. 

#### 3. Освобождение памяти

Функция **regfree()** освобождает память, которая была предоставлена шаблону **regex** во время компиляции функцией **regcomp()**.

```c
void regfree(regex_t *regex);
```
#### 4. Обработка ошибок

Для преобразования кодов ошибок, которые могут быть возвращены из функций **regcomp()** и **regexec()**, в строки сообщений об ошибках существует функция **regerror()**:

```c
size_t regerror(int errcode, const regex_t *regex,
                char *errbuf, size_t errbuf_size);
```
-  `errcode`        :  код ошибки;
-  `regex`           :  шаблон;
-  `errbuf`          :  указатель на строку, в которую запишется сообщение об ошибке, или                                   `NULL`;  
-  `errbuf_size` :  размер буфера сообщения;
-  `return`          :  реальный размер, который требуется для содержащейся строки, с                                          сообщением об ошибке.

#### 5. Пример работы

```c
#include <stdio.h>
#include <regex.h>

int main() {
	char *string = "hello 11111 worlld";
	regex_t regex[2];               // массив регулярных выражений
	regcomp(&regex[0], "hello", 0); // создание первого регулярного выражения
	regcomp(&regex[1], "world", 0); // создание второго регулярного выражения
	regmatch_t match;               // переменная для отлова совпадений
	for (int i = 0; i < 2; i++) {
		if (regexec(&regex[i], string, 1, &match, 0) == 0) { // найдено совпадение
			printf("%.*s", match.rm_eo - match.rm_so, string + match.rm_so); 
		}
	}
	for (int i = 0; i < 2; i++) {
		regfree(&regex[i]);        // освобождение ресурсов
	}
	return 0;
}
```
