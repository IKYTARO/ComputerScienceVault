# Опции программы (program options)

## Передача опций в программу

Передача опций в программу на языке С/C++ осуществляется через аргументы функции `main()` (подробнее описано в [Brian Kernighan, Dennis Ritchie "The_C_Programming_Language", 5.10. Command-line Arguments]):
```cpp
int main(int argc, char *argv[]);
```
- `argc`(arguments counter) - количество аргументов;
- `argv`(arguments values)   - массив аргументов (строка `argv[i]` - имя или значение аргумента).

 **В качестве первого аргумента (`argv[0]`) программа всегда получает свое имя.** 

## Виды опций

-  Короткая опция          : один символ, например `-h`;
-  Длинная опция           : полное имя опции, например `--help`;
-  Опция с аргументом  : короткая или длинная опция со значением, например `-s 10` или `--size=10`.

## Обработка коротких опций

Для обработки как коротких, так и длинных опций существуют функции в стандартной библиотеке языка С. Для обработки коротких опций служит функция `getopt`:
```cpp
int getopt(int argc, char *argv[], char const *optstring);
```
- `optstring` : список (строка) коротких опций, где обозначения строятся по следующим правилам:
	-  "s"   (одиночный символ)      - простая опция без аргумента;
	-  "s:"  (символ с двоеточием)   - опция с обязательным аргументом;
	-  "s::" (двойное двоеточие)      - опция с необязательным аргументом;
	
	 Пример: `char *optsring = "abs:vst::";`.
	 **Опция `W` зарезервирована в POSIX.2 для расширения возможностей и не может быть использована.** 
	 
Перебор командной строки осуществляется в цикле. В качестве результата функция `getopt` возвращает символ/имя (`s`) соответствующей опции, символ `?` если найдена опции не из списка `optstring` или -1, когда опции закончились. 
```cpp
int option;
char const *short_options = "fts:v::h";
while ((option = getopt(argc, argv, short_options)) != -1) {
	switch (option) {
		case 'f': ... break;
		case 't': ... break;
		case 's': ... break;
		case 'v': ... break;
		case 'h': ... break;
		case '?': ... break; // наткнулись на ошибку
	}
}
```
Библиотека также предоставляет следующие глобальные переменные:
```cpp
extern char *optarg; // содержит аргумент текущей опции
extern int optind;   // содержит индекс текущей опции
extern int opterr;   // содержит код ошибки
extern int optopt;
```
Если находим параметр не из списка `optstring`, то выводится ошибка в `stderr`, а код ошибки заносится в `opterr` (сама функция при этом возвращает `?` как упомянуто выше). Вывод ошибки можно запретить, установив `opterr = 0;` и добавить собственную обработку.

## Обработка длинный опций

Для обработки длинных опций необходимо подключить заголовочный файл и использовать функцию `getopt_long`:
```cpp
#include <getopt.h>
```
```cpp
int getopt_long(int argc, char *argv[], char const *short_options, 
			    struct option *long_options, int *longindex);
```
-  `optindex`          : содержит индекс текущей опции в массиве `long_options`:

Важно учесть, что при нахождении короткой опции значение поля `optindex` будет неопределенным. Поэтому устанавливаем `optindex = -1` и обновляем на каждом шаге обработки массива `argv`. Это позволит понять какое название мы встретили, короткое или длинное:
    - `optindex < 0`   : короткий параметр; 
	- `optindex >= 0` : длинный параметр (его индекс в массиве `long_options`).

-  `long_options`   : массив специальных структур для длинных опций:
```cpp
struct option {
	char const *name; // название длинной опции
	int has_arg;      // нужен ли аргумент для данной опции
	int *flag;        // содержит val, если опция найдена
	int val;          // возвращаемое значение функции getopt_long
};

// Значения параметра has_arg:

#define no_argument        0  
#define required_argument  1
#define optional_argument  2
```
Поле `flag` задает указатель на флаг, в который помещается значение `val`, если найден данный параметр (сама функция `getopt_long` при этом возвращает 0). Если `flag = NULL`, то функция возвращает значение `val` в качестве результата работы. 

Поле `val` содержит значение, которое помещается по указателю `flag` или возвращается из функции 'getopt_long'.

==Последняя запись в массиве== `long_options` должна содержать нулевые значения, для того чтобы функция могла однозначно определить конец массива опций. 

==Чтобы одновременно обрабатывать и короткие, и длинные опции== (которые соответствуют друг другу, например `-h` и `--help`) необходимо положить в поле `val` короткое имя опции, а в поле `flag` положить `NULL`. Например,
```cpp
const char *short_options = "hs::f:";

struct option const long_options[] = {
	{"help", no_argument, NULL, 'h'},        // опция без аргумента
	{"size", optional_argument, NULL, 's'},  // опция с обязательным аргументом (:)
	{"file", required_argument, NULL, 'f'},  // опция с необязательным аргументом (::)
	{NULL, 0, NULL, 0},                      // нулевая запись - конец массива
};

int option, optindex = -1, opterr = 0;
while ((option = getopt_long(argc, argv, short_options, 
                            long_options, &optindex)) != -1) {
    switch (option) {
	    case 'h': ... break;
	    case 's': 
		    if (optindex < 0)
			    handleShortOption(...);
			else
				handleLongOption(...);
			break;
	    case 'f': ... break;
	    case '?': ... break; // обрабатываем ошибку unrecognized option
    }
    optindex = -1;
}
```

## Замечания

-  Нужно быть аккуратным с `optional_argument`, так как пробел между именем опции и аргументом может быть воспринят как отсутствие аргумента при неправильной записи.
-  Существует функция для обработки только длинных опций `getopt_long_only`. Встретив короткое название опции она попытается интерпретировать его как длинное, что может привести к ошибке. Поэтому лучше избегать ее использования.
```cpp
int getopt_long_only(int argc, char *argv[], char const *short_options, 
			        struct option *long_options, int *longindex);
```